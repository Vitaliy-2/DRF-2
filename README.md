Джанго рест фреймворк
Это архитектурный стиль взаимодействия сервера с различными клиентами (смартфоны, любое устройство с интернетом).

1) В новом проекте создаем виртуальное окружение.
2) Установка джанго:
pip install django
requirements.txt
pip freeze > requirements.txt
3) Создание нового проекта в Django:
django-admin startproject drfsite .
4) Запуск сервера разработки: "python manage.py runserver"
5) Выполнение миграций: "python manage.py migrate"
6) В settings - язык и время
7) Создание нового приложения в проекте: "python manage.py startapp example"
8) В settings подключение приложения - 'example.apps.ExampleConfig'
9) Добавление моделей. Создание, применение миграций.
10) Создание суперпользователя - "python manage.py createsuperuser"
11) Установка библиотеки DRF: "pip install djangorestframework"
12) В settings - 'rest_framework'
ПАКЕТ УСТАНОВЛЕН И ГОТОВ К РАБОТЕ
generics - в этой ветке множество базовых классов для представления

Итог: В views пишем класс, который наследуется от базового класса DRF. Этот класс будет обрабатывать url маршрут. Принимая сериализованные данные  из файла serializer.py
В файле serializer.py пользуясь инструментами DRF пишем класс, в котором указываем какие данные будем превращать в json формат для отправки.
А это: Саму модель и её конкретные поля. Этот весь класс указывается в views и нужные данные сериализуются при переходе по маршруту.
Суть в том, что по API ЗАПРОСАМ на телефон не передается HTML страница полностью, а она рисуется, используя данные из json файла.

APIView - Главный класс, от которого наследуются последующие классы. Самый базовый функционал.

Для проверки на POST запрос в приложении Postman:
File -> New Tab (Создаем новую вкладку) -> Вставляем usrl запрос.

Обработка запросов в представлении DRF:
В заголовке запроса указывается какой  метод используется Post, GET и тд.
И перед обработкой данных сначала DRF ищет какой метод указан, если в views он
не описан, то выдает ошибку, если описан - происходит сериализация данных.

Данные при сериализации превращаются в словарь и далее в json файл в байтовом виде.
При получении json файла, он парсится в словарный вид, данные проходят валидацию и потом выдаются.

Изучил методы создания, редактирования и сохранения. Описывая функции в классе в views, каждая функция работает с сериализатором
и понимая сколько аргументов входит, такой метод и использует.
Для создания требуются лишь data словарь с данными, а для редактирования - data словарь и pk записи.

Сериалайзер свяазнный с моделью сильно упрощает написание кода, но знать как это работает под капотом джанго нужно.
Также и во views, наследование от конкретных классов снижает объем кода до двух строк.
Очень удобно в использовании, но важно знать, как все работает внутри джанго, ведь проекты бывают разные.

Настройка в settings - Глобальные настройки DRF (передача данных в JSON формате, разрешение/запрет действий CRUD в браузере)


Это если не использовать роутеры и писать каждый путь отдельно
# path('api/v1/carlist/', CarViewSet.as_view({'get': 'list'})), :
'get' - метод для обработки запроса
'list' - метод, который будет вызываться в самом ViewSet для обработки GET запроса.


Создаем объект роутера
# router = routers.SimpleRouter()
регистрируем его.
1 аргумент - префикс для набора маршрутов (car)
2 аргумент - указать класс вью сета
# router.register(r'car', CarViewSet)

router - позволяет реализовывать в одну строку два маршрута - список записей и конкретная запись по pk. Это происходит автоматически благодаря SimpleRouter.
# path('api/v1/', include(router.urls)),  # http://127.0.0.1:8000/api/v1/car/ или http://127.0.0.1:8000/api/v1/car/7/


Чтобы убрать дублирование кода у разных методов (удаления, обновления, чтения, редактирования, добавления) нужно импортировать "viewsets.ModelViewSet" связанный с моделью.
class CarViewSet(viewsets.ModelViewSet):
    queryset = Car.objects.all()
    serializer_class = CarSerializer

Теперь изменения в urls и views помогают реализовывать все операции CRUD в нескольких строк кода.
Сам класс ModelViewSet внутри DRF наследуется от следующих миксинов:
# class ModelViewSet(mixins.CreateModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, mixins.ListModelMixin, GenericViewSet):
Эти миксины можно в ручную указывать в наследниках и выбирать какие нужны, какие нет. Например убрать миксин DestroyModelMixin, тогда функционал удаления пропадет.