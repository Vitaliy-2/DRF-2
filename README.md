Джанго рест фреймворк
Это архитектурный стиль взаимодействия сервера с различными клиентами (смартфоны, любое устройство с интернетом).

1) В новом проекте создаем виртуальное окружение.
2) Установка джанго:
pip install django
requirements.txt
pip freeze > requirements.txt
3) Создание нового проекта в Django:
django-admin startproject drfsite .
4) Запуск сервера разработки: "python manage.py runserver"
5) Выполнение миграций: "python manage.py migrate"
6) В settings - язык и время
7) Создание нового приложения в проекте: "python manage.py startapp example"
8) В settings подключение приложения - 'example.apps.ExampleConfig'
9) Добавление моделей. Создание, применение миграций.
10) Создание суперпользователя - "python manage.py createsuperuser"
11) Установка библиотеки DRF: "pip install djangorestframework"
12) В settings - 'rest_framework'
ПАКЕТ УСТАНОВЛЕН И ГОТОВ К РАБОТЕ
generics - в этой ветке множество базовых классов для представления

Итог: В views пишем класс, который наследуется от базового класса DRF. Этот класс будет обрабатывать url маршрут. Принимая сериализованные данные  из файла serializer.py
В файле serializer.py пользуясь инструментами DRF пишем класс, в котором указываем какие данные будем превращать в json формат для отправки.
А это: Саму модель и её конкретные поля. Этот весь класс указывается в views и нужные данные сериализуются при переходе по маршруту.
Суть в том, что по API ЗАПРОСАМ на телефон не передается HTML страница полностью, а она рисуется, используя данные из json файла.

APIView - Главный класс, от которого наследуются последующие классы. Самый базовый функционал.

Для проверки на POST запрос в приложении Postman:
File -> New Tab (Создаем новую вкладку) -> Вставляем usrl запрос.

Обработка запросов в представлении DRF:
В заголовке запроса указывается какой  метод используется Post, GET и тд.
И перед обработкой данных сначала DRF ищет какой метод указан, если в views он
не описан, то выдает ошибку, если описан - происходит сериализация данных.

Данные при сериализации превращаются в словарь и далее в json файл в байтовом виде.
При получении json файла, он парсится в словарный вид, данные проходят валидацию и потом выдаются.

Изучил методы создания, редактирования и сохранения. Описывая функции в классе в views, каждая функция работает с сериализатором
и понимая сколько аргументов входит, такой метод и использует.
Для создания требуются лишь data словарь с данными, а для редактирования - data словарь и pk записи.

Сериалайзер свяазнный с моделью сильно упрощает написание кода, но знать как это работает под капотом джанго нужно.
Также и во views, наследование от конкретных классов снижает объем кода до двух строк.
Очень удобно в использовании, но важно знать, как все работает внутри джанго, ведь проекты бывают разные.

Настройка в settings - Глобальные настройки DRF (передача данных в JSON формате, разрешение/запрет действий CRUD в браузере)


Это если не использовать роутеры и писать каждый путь отдельно
# path('api/v1/carlist/', CarViewSet.as_view({'get': 'list'})), :
'get' - метод для обработки запроса
'list' - метод, который будет вызываться в самом ViewSet для обработки GET запроса.


Создаем объект роутера
# router = routers.SimpleRouter()
регистрируем его.
1 аргумент - префикс для набора маршрутов (car)
2 аргумент - указать класс вью сета
# router.register(r'car', CarViewSet)

router - позволяет реализовывать в одну строку два маршрута - список записей и конкретная запись по pk. Это происходит автоматически благодаря SimpleRouter.
# path('api/v1/', include(router.urls)),  # http://127.0.0.1:8000/api/v1/car/ или http://127.0.0.1:8000/api/v1/car/7/


Чтобы убрать дублирование кода у разных методов (удаления, обновления, чтения, редактирования, добавления) нужно импортировать "viewsets.ModelViewSet" связанный с моделью.
class CarViewSet(viewsets.ModelViewSet):
    queryset = Car.objects.all()
    serializer_class = CarSerializer

Теперь изменения в urls и views помогают реализовывать все операции CRUD в нескольких строк кода.
Сам класс ModelViewSet внутри DRF наследуется от следующих миксинов:
# class ModelViewSet(mixins.CreateModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, mixins.ListModelMixin, GenericViewSet):
Эти миксины можно в ручную указывать в наследниках и выбирать какие нужны, какие нет. Например убрать миксин DestroyModelMixin, тогда функционал удаления пропадет.

Роутеры DefaultRouter и SimpleRouter
При отработке DefaultRouter в пути без приставки "car" отобразится страница с рабочими маршрутами, то есть даем понять пользователю какие маршруты работают.
А SimpleRouter не рендарит этот путь без приставки "car", нельзя посмотреть какие маршруты есть.
Это их отличия.
DefaultRouter - формирует список маршрутов и связывает их с определенным юсетом.

Можно с помощью декоратора action создавать новый маршрут в классе во views


Ограничение прав доступа (permissions)
Расширили модель Car добавив ключ связывающий с таблицей пользователей. Создали и применили миграции, при создании выбираем первый пункт и значение по дефолту "1".

Указывам в классе views. Добавлять запись может только авторизованный пользователь, остальные только читать.
# permission_classes = (IsAuthenticatedOrReadOnly, )

Только админы могут что-то делать
# permission_classes = (IsAdminUser, )

# def has_permission(self, request, view):  - Когда в return получаем булево, типо пользователь является админом.
# def has_object_permission(self, request, view, obj): - Когда в return идет сравнение в конкретной записью, например что автор данной записи является данный пользователь, тогда доступ предоставляется.

Можно наследоваться от встроенных ограничениях, а можно писать свои, указывая нужную логику - в файле permissions.py
В своих ограничениях указали, что если запрос безопасный (GET), то можно все выдавать список или отдельную запись, но если запрос ведет на какие-либо действия (DELETE, PUT) то уже проверяются конкретные права (администратор, авторизованный)

В settings можно глобально для всего DRF задать какие-то права, но они будут перекрываться правами из views.


Авторизация и аутентификация

# 1 Session-based authentication
Данный способ осуществляется через session_id и Cookies. То есть при авторизации пользователя в форме - в базе данных создается id сессии привязанная к этому юзеру, это id также заносится в куки браузера. Благодаря этому, при закрытии сайта и повторном его открытии, юзер также будет авторизован, так как пройдет валидация сравнения сессии айди из базы данных и куками сайта.
Плюсы: удобство, распространенность.
Минусы: привязка к конкретному компьютеру, привязка к домену сайта, ограниченное время хранения id сессии в куках.

1. В урлах прописываем путь.
2. Появятся два маршрута для авторизации и выхода.
3. session_id в браузере можно найти: код элемента - сеть - car/ - заголовки - Cookie
4. session_id - используется на аутентификации пользователя

# 2 Token-based authentication
Использование определенного ключа (токена) для идентификации пользователя.
Токен не привязан не к домену, не к браузеру, главное указать его в заголовке запроса. Благодаря этому сайт может взаимодействовать с самыми разными конечными устройствами.
Работа токенов: при авторизации в базу данных записывается ключ - токен, который связывается с конкретным пользователем, далее он обратно отсылается пользователю и сохраняется в защищенном локальном хранилище. Далее при обращении пользователя к сайту, например по GET запросу, в запросе также передается этот токен. Сервер смотрит есть ли такой токен и если он его находит, понимает с каким пользователем он связан и дает или не дает права на обращение. Сам токен хранится долгое время.

# Библиотека Djoser - обычная аутентификация токенами.
Установка пакета:
1. pip install djoser
2. pip freeze > requirements.txt
3. В settings добавляем в INSTALLED_APPS два поля:
'rest_framework.authtoken' - чтобы DRF использовал свою стандартную таблицу с токенами.
'djoser'
4. python manage.py migrate  - таблица добавляется в БД
5. Прописать необходимые маршруты urls - 2 штуки
6. В settings разрешить DRF аутентификацию по токенам
'DEFAULT_AUTHENTICATION_CLASSES'

для авторизации + показывает доступный адрес
1. Для админа предоставялет список данных зарегистрированных пользователей
2. Если обычный юзер зашел по этому маршруту - показывает только его данные
3. Если не залогинен - данные показываться не будут
# path('api/v1/auth/', include('djoser.urls')),

С помощью пакета djoser можно выполнять:
1. Авторизацию - http://127.0.0.1:8000/auth/token/login/ (logout)/ - при login создается и выдается token
2. Аутентификацию
3. Регистрацию - через POST запрос и форму отправить данные
4. Его удаление
5. Изменение данных
6. и тд

По дефолту каждая вьюшка способна аутентифицировать по сессиям и токенам, но можно настраиваться отдельно, например, аутентификация только по токенам:
# authentication_classes = (TokenAuthentication, )


# 3 JSON Web Token (JWT) - авторизация
Токен состоит из 3х чатей, разделенные точками.
1. header - содержит информацию об алгоритмах шифрования и типе токена
2. payload - полезные данные (информация о пользователе и время жизни этого токена)
3. signature - подпись

header и payload - обычные json строки, содержащие определенную информацию. Эти две части из json строк преобразуются в строку различных символов (base64 - кодирует данные, представляет их в ином виде).
То есть данные в JWT не защищены от просмотра, но менять header и payload не получится, так как есть 3 часть - signature.

signature берет закодированные данные из первых двух частей, соединяет их в одну строку, а затем полученная строка шифруется с помощью указанного в header алгоритма (например "HS256"). Получается можно проверять по данным header и payload, что эта подпись коректная или нет. То есть после кодирования и получения подписи signature, данные в header или payload как-то поменять, то подпись (signature) уже не будет соответствовать этим данным, а значит сервер может понимать изменены данные или нет. Благодаря signature мы защищаем header и payload от изменения. Читать их можно, а менять нет.

# jwt_token = header.payload.signature

# JWT-authorization / authentication

Использование:
Например, когда единая учетная запись используется множеством независимых серсисов. Например Google. Один раз авторизуемся и получаем доступ ко всем инструментам (ютуб, gmail, Adsense и тд).
Если бы не JWT, то каждый сервис обращался бы в единую базу данных, чтобы рповерить присутствует ли там токен или нет.

Процедцура:
1. Авторизация
Неважно к какому сервису мы обратились, этот сервис обращается в  сервер БД. Если учетные данные совпадают, то сервер авторизации возвращает пользователю два токена (access_token и refresh_token). Дополнительно refresh_token сохраняется в БД сервера авторизации, а на стороне клиента сохраняются оба в локальном хранилище.

Для доступа к сервисам используется access_token. Время жизни этого токена около 5 минут.
access_token содержит все информацию о пользователе и цифровую подпись, это значит что сервис понимает кто запрашивает доступ, и имеет возможность проверить коректность токена по его подписи, так как все сервисы знаю этот единые секретный ключ, которым шифруется эта подпись. Значит практически невозможно подменить данные в access_token.

refresh_token имеет время жизни от суток. Когда вермя жизни access_token заканчивается, на сервер авторизации отправляется refresh_token и пользователю назначаются новые access_token и refresh_token. Получается что токены все меняются, а доступ остается, это необходимо для защиты от злоумышленников. При этой подмене пользователю не нужно заново авторизовываться.
Если злоумышленник получит себе refresh_token (самый неприятный момент), то у него будет доступ ко всем сервисам до тех пор, пока пользователь не выйдет из системы, не разлогинется. При выходе из системы удаляются все refresh_token.

Реализация алгоритмов авторизации и аутентификации могут различаться.

Большинство сайтов используют обычные токены, нет необходимости в JWT. Зачастую в крупных компаниях, но есть варианты и в небольших проектах: на файлообменниках можно организовать временный доступ к скачиванию файлов через JWT-токены, при этом не спользовать refresh_token, а только access_token.


# JWT - authentication
JWT-токены (библиотека Simple JWT)
"https://django-rest-framework-simplejwt.readthedocs.io/en/latest/getting_started.html"
Simple JWT - популярная и может работать в связке с Djoser
Установка:
1. pip install djangorestframework-simplejwt
2. pip freeze > requirements.txt
3. В settings: 'rest_framework_simplejwt.authentication.JWTAuthentication',
4. В урлах прописать маршруты
5. В settings из документации добавить большой список настроек
6. python manage.py runserver
7. api/v1/token/ - по маршруту снизу логинимся и видим полученные access_token и refresh_token токены.
8. Переходим на сайт jwt.io или https://www.jstoolset.com/jwt - они декодируют токены
9. Чтобы получить доступ к странице сайта, нужно в постмане в хеадерс при запросе указать Авторизатион и токен "Bearer "сам токен""
10. Если это делать долго то истечет время жизни токена, для этого нужно перейти на путь 'api/v1/token/refresh/' - вставить туда refresh_token - сайт выдаст новый access_token - который будет работать.



ПАГИНАЦИЯ
https://www.django-rest-framework.org/api-guide/pagination/

1. В settings добавляем настройки:
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination',
    'PAGE_SIZE': 2,
И уже все работает. Но пагинация автоматически срабатывает на всех страницах со списками.
Чтобы это исправить, во views нужно определить свой класс пагинации. И указать его в нужной вьюшке.
Указав настройки в settings они распространяются на весь проект. Для индивидуальных реализация необходимо в views прописывать классы пагинаторы с нужными значениями для определенных маршрутов.
